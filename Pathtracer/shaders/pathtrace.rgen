#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

#include "raypayload.glsl"
#include "sampling.glsl"
#include "../../AstraEngine/AstraCore/shaders/host_device.h"

layout(set = 1, binding = eCamera) uniform _CameraUniform { CameraUniform uni; };
layout (location = 0) rayPayloadEXT hitPayload prd;
layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba32f) uniform image2D image;
layout(push_constant) uniform _PushConstantRay { PushConstantRay pcRay; };

float hash(vec2 p) {
    return fract(sin(dot(p ,vec2(12.9898,78.233))) * 43758.5453);
}

// Función para generar un número entero aleatorio en un rango
int randomInt(vec2 uv, int min, int max) {
    // Generamos un valor hash y lo escalamos al rango deseado
    float randomValue = hash(uv);
    int range = max - min + 1;
    return min + int(floor(randomValue * float(range)));
}


void main() 
{
    uint seed = randomInt(gl_LaunchIDEXT.xy, 0, 100);

    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
    vec2 d = inUV * 2.0 - 1.0;

    vec4 origin = uni.viewInverse * vec4(0,0,0,1);
    vec4 target = uni.projInverse * vec4(d.x, d.y, 1, 1);
    vec4 direction = uni.viewInverse * vec4(normalize(target.xyz), 0);

    uint rayFlags = gl_RayFlagsOpaqueEXT;
    float tMin = 0.001f;
    float tMax = 10000.0f;

    prd.hitValue    = vec3(0);
    prd.depth       = 0;
    prd.rayOrigin   = origin.xyz;
    prd.rayDir      = direction.xyz;
    prd.weight      = vec3(0);
    prd.seed        = seed;

    vec3 hitValue = vec3(0);
    vec3 currentWeight = vec3(1);

    for(uint i=0; i < pcRay.maxDepth; i++)
    {
    traceRayEXT(topLevelAS,     // acceleration structure
                rayFlags,       // rayFlags
                0xFF,           // cullMask
                0,              // sbtRecordOffset
                0,              // sbtRecordStride
                0,              // missIndex
                prd.rayOrigin,     // ray origin
                tMin,           // ray min range
                prd.rayDir,  // ray direction
                tMax,           // ray max range
                0               // payload (location = 0)
    );
    hitValue += prd.hitValue * currentWeight;
    currentWeight *= prd.weight;

    }
  if(pcRay.frame > 0)
  {
    float a         = 1.0f / float(pcRay.frame + 1);
    vec3  old_color = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).xyz;
    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(mix(old_color, hitValue, a), 1.f));
  }
  else
  {
    // First frame, replace the value in the buffer
    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(hitValue, 1.f));
  }
}
